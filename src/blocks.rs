use sha3::{Digest, Sha3_256};

use crypto::prelude::*;
use crypto::ring::SignRing;
use wire::len_to_u16_vec;

use std::fmt;


pub mod prelude {
    pub use super::{Block, BlockType, BlockIdentifier, BlockPointer};
    pub use super::{InitBlock, RekeyBlock, AlertBlock, InfoBlock};
}


#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlockPointer(pub [u8; 32]);

impl BlockPointer {
    pub fn from_slice(bytes: &[u8]) -> Option<BlockPointer> {
        if bytes.len() == 32 {
            let mut pointer = [0; 32];
            pointer.copy_from_slice(bytes);
            Some(BlockPointer(pointer))
        } else {
            None
        }
    }

    pub fn slice(&self) -> (String, String) {
        // TODO: somewhat inefficient
        let hex = format!("{:x}", self);
        let (prefix, hash) = hex.split_at(4);
        (prefix.into(), hash.into())
    }

    pub fn from_hex(mut hex: &str) -> Result<BlockPointer, ()> {
        let result: Result<Vec<u8>, _> = (0..32)
            .map(|_| {
                let (chunk, remain) = hex.split_at(2);
                hex = remain;
                chunk
            })
            .map(|x| {
                u8::from_str_radix(x, 16)
            })
            .collect();

        match result {
            Ok(result) => match BlockPointer::from_slice(&result) {
                Some(pointer) => Ok(pointer),
                None => Err(()),
            },
            Err(_) => Err(()),
        }
    }
}

impl From<Option<[u8; 32]>> for BlockPointer {
    fn from(pointer: Option<[u8; 32]>) -> BlockPointer {
        match pointer {
            Some(pointer) => BlockPointer(pointer),
            None => BlockPointer([0; 32]),
        }
    }
}

impl fmt::LowerHex for BlockPointer {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for x in self.0.iter() {
            write!(f, "{:02x}", x)?
        }
        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Block {
    inner: BlockType,
    signature: Signature,
}

impl Block {
    fn sign(inner: BlockType, keyring: &SignRing) -> Result<Block, ()> {
        let buf = inner.encode();
        let signature = keyring.sign_longterm(&buf.to_vec());

        Ok(Block {
            inner,
            signature,
        })
    }

    #[inline]
    pub fn sha3(&self) -> BlockPointer {
        let result = Sha3_256::digest(&self.encode());
        BlockPointer::from_slice(result.as_slice()).unwrap()
    }

    pub fn msg(&self) -> Option<&Vec<u8>> {
        match self.inner {
            BlockType::Init(_) => None,
            BlockType::Rekey(_) => None,
            BlockType::Alert(ref block) => Some(block.bytes()),
            BlockType::Info(ref block) => Some(block.bytes()),
        }
    }

    pub fn from_network(inner: Unverified<BlockType>, signature: Signature) -> Unverified<Block> {
        Unverified(Block {
            inner: inner.0,
            signature: signature,
        })
    }

    pub fn init(prev: BlockPointer, mut keyring: &mut SignRing) -> Result<Block, ()> {
        let inner = InitBlock::new(prev, &mut keyring);
        Block::sign(BlockType::Init(inner), &keyring)
    }

    pub fn rekey(prev: BlockPointer, keyring: &mut SignRing) -> Result<Block, ()> {
        let inner = keyring.rekey(prev);
        Block::sign(BlockType::Rekey(inner), &keyring)
    }

    pub fn alert(prev: BlockPointer, keyring: &mut SignRing, bytes: Vec<u8>) -> Result<Block, ()> {
        let inner = keyring.alert(prev, bytes);
        Block::sign(BlockType::Alert(inner), &keyring)
    }

    pub fn info(prev: BlockPointer, mut keyring: &mut SignRing, bytes: Vec<u8>) -> Result<Block, ()> {
        let inner = InfoBlock::new(prev, &mut keyring, bytes);
        Block::sign(BlockType::Info(inner), &keyring)
    }

    pub fn encode(&self) -> Vec<u8> {
        let mut buf: Vec<u8> = Vec::new();
        buf.extend(self.inner.encode());
        buf.extend(self.signature.0.iter());
        buf
    }

    pub fn encode_inner(&self) -> Vec<u8> {
        self.inner.encode()
    }

    pub fn prev(&self) -> &BlockPointer {
        self.inner.prev()
    }

    pub fn inner(&self) -> &BlockType {
        &self.inner
    }

    pub fn signature(&self) -> &Signature {
        &self.signature
    }
}

impl From<Block> for Unverified<Block> {
    fn from(block: Block) -> Unverified<Block> {
        Unverified(block)
    }
}

#[derive(Debug, PartialEq, Eq)]
pub enum BlockIdentifier {
    Init,
    Rekey,
    Alert,
    Info,
}

impl BlockIdentifier {
    pub fn to_block_identifier(x: u8) -> Result<BlockIdentifier, ()> {
        match x {
            0x00 => Ok(BlockIdentifier::Init),
            0x01 => Ok(BlockIdentifier::Rekey),
            0x02 => Ok(BlockIdentifier::Alert),
            0x03 => Ok(BlockIdentifier::Info),
            _ => Err(()),
        }
    }

    pub fn to_byte(&self) -> u8 {
        match *self {
            BlockIdentifier::Init => 0x00,
            BlockIdentifier::Rekey => 0x01,
            BlockIdentifier::Alert => 0x02,
            BlockIdentifier::Info => 0x03,
        }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        vec![self.to_byte()]
    }
}


#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum BlockType {
    Init(InitBlock),
    Rekey(Signed<RekeyBlock>),
    Alert(Signed<AlertBlock>),
    Info(Signed<InfoBlock>),
}

impl BlockType {
    fn prev(&self) -> &BlockPointer {
        match *self {
            BlockType::Init(ref inner) => inner.prev(),
            BlockType::Rekey(ref inner) => inner.prev(),
            BlockType::Alert(ref inner) => inner.prev(),
            BlockType::Info(ref inner) => inner.prev(),
        }
    }

    fn encode(&self) -> Vec<u8> {
        match *self {
            BlockType::Init(ref inner) => inner.encode(),
            BlockType::Rekey(ref inner) => inner.encode(),
            BlockType::Alert(ref inner) => inner.encode(),
            BlockType::Info(ref inner) => inner.encode(),
        }
    }
}

impl From<Unverified<InitBlock>> for Unverified<BlockType> {
    fn from(block: Unverified<InitBlock>) -> Unverified<BlockType> {
        Unverified(BlockType::Init(block.0))
    }
}

impl From<Unverified<Signed<RekeyBlock>>> for Unverified<BlockType> {
    fn from(block: Unverified<Signed<RekeyBlock>>) -> Unverified<BlockType> {
        Unverified(BlockType::Rekey(block.0))
    }
}

impl From<Unverified<Signed<AlertBlock>>> for Unverified<BlockType> {
    fn from(block: Unverified<Signed<AlertBlock>>) -> Unverified<BlockType> {
        Unverified(BlockType::Alert(block.0))
    }
}

impl From<Unverified<Signed<InfoBlock>>> for Unverified<BlockType> {
    fn from(block: Unverified<Signed<InfoBlock>>) -> Unverified<BlockType> {
        Unverified(BlockType::Info(block.0))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct InitBlock {
    prev: BlockPointer,
    pubkey: PublicKey,
}

impl InitBlock {
    pub fn new(prev: BlockPointer, keyring: &mut SignRing) -> InitBlock {
        let pubkey = keyring.init();
        InitBlock {
            prev,
            pubkey,
        }
    }

    pub fn from_network(prev: BlockPointer, pubkey: PublicKey) -> Unverified<InitBlock> {
        Unverified(InitBlock {
            prev,
            pubkey,
        })
    }

    #[inline]
    pub fn prev(&self) -> &BlockPointer {
        &self.prev
    }

    pub fn pubkey(&self) -> &PublicKey {
        &self.pubkey
    }
}

impl Signable for InitBlock {
    fn encode(&self) -> Vec<u8> {
        let mut buf = Vec::new();
        buf.extend(self.prev.0.iter());
        buf.extend(BlockIdentifier::Init.to_vec());
        buf.extend(self.pubkey.0.iter());
        buf
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct RekeyBlock {
    prev: BlockPointer,
    /// New session key
    pubkey: PublicKey,
}

impl RekeyBlock {
    pub fn new(prev: BlockPointer, pubkey: PublicKey) -> RekeyBlock {
        RekeyBlock {
            prev,
            pubkey,
        }
    }

    pub fn from_network(prev: BlockPointer, pubkey: PublicKey, signature: Signature) -> Unverified<Signed<RekeyBlock>> {
        Unverified(Signed(RekeyBlock {
            prev,
            pubkey,
        }, signature))
    }

    #[inline]
    pub fn prev(&self) -> &BlockPointer {
        &self.prev
    }

    pub fn pubkey(&self) -> &PublicKey {
        &self.pubkey
    }
}

impl Signable for RekeyBlock {
    fn encode(&self) -> Vec<u8> {
        let mut buf = Vec::new();
        buf.extend(self.prev.0.iter());
        buf.extend(BlockIdentifier::Rekey.to_vec());
        buf.extend(self.pubkey.0.iter());
        buf
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct AlertBlock {
    prev: BlockPointer,
    /// New session key
    pubkey: PublicKey,
    bytes: Vec<u8>,
}

impl AlertBlock {
    pub fn new(prev: BlockPointer, pubkey: PublicKey, bytes: Vec<u8>) -> AlertBlock {
        AlertBlock {
            prev,
            pubkey,
            bytes,
        }
    }

    pub fn from_network(prev: BlockPointer, pubkey: PublicKey, bytes: Vec<u8>, signature: Signature) -> Unverified<Signed<AlertBlock>> {
        Unverified(Signed(AlertBlock {
            prev,
            pubkey,
            bytes,
        }, signature))
    }

    #[inline]
    pub fn prev(&self) -> &BlockPointer {
        &self.prev
    }

    pub fn pubkey(&self) -> &PublicKey {
        &self.pubkey
    }

    pub fn bytes(&self) -> &Vec<u8> {
        &self.bytes
    }

    pub fn clone_bytes(&self) -> Vec<u8> {
        self.bytes.clone()
    }
}

impl Signable for AlertBlock {
    fn encode(&self) -> Vec<u8> {
        let mut buf = Vec::new();
        buf.extend(self.prev.0.iter());
        buf.extend(BlockIdentifier::Alert.to_vec());
        buf.extend(self.pubkey.0.iter());
        buf.extend(len_to_u16_vec(self.bytes.len()).iter());
        buf.extend(&self.bytes);
        buf
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct InfoBlock {
    prev: BlockPointer,
    bytes: Vec<u8>,
}

impl InfoBlock {
    pub fn new(prev: BlockPointer, keyring: &mut SignRing, bytes: Vec<u8>) -> Signed<InfoBlock> {
        let block = InfoBlock {
            prev,
            bytes,
        };
        let signature = keyring.sign_session(&block.encode());

        Signed(block, signature)
    }

    pub fn from_network(prev: BlockPointer, bytes: Vec<u8>, signature: Signature) -> Unverified<Signed<InfoBlock>> {
        Unverified(Signed(InfoBlock {
            prev,
            bytes,
        }, signature))
    }

    #[inline]
    pub fn prev(&self) -> &BlockPointer {
        &self.prev
    }

    pub fn bytes(&self) -> &Vec<u8> {
        &self.bytes
    }

    pub fn clone_bytes(&self) -> Vec<u8> {
        self.bytes.clone()
    }
}

impl Signable for InfoBlock {
    fn encode(&self) -> Vec<u8> {
        let mut buf = Vec::new();
        buf.extend(self.prev.0.iter());
        buf.extend(BlockIdentifier::Info.to_vec());
        buf.extend(len_to_u16_vec(self.bytes.len()).iter());
        buf.extend(&self.bytes);
        buf
    }
}


#[cfg(test)]
mod tests {
    // use machine::{SignMachine, VerifyMachine};
    use crypto::{self, SignRing};
    use crypto::{PublicKey, Signature};
    use blocks::prelude::*;

    fn bytes2vec(x: &[u8]) -> Vec<u8> {
        let mut vec = Vec::new();
        vec.extend(x);
        vec
    }

    /*
    #[test]
    fn init() {
        let (pk, sk) = crypto::gen_keypair();

        let _sm = SignMachine::new(pk.clone(), sk, None);
        let _vm = VerifyMachine::new(pk, None);
    }

    #[test]
    fn simple() {
        let (pk, sk) = crypto::gen_keypair();

        let sm = SignMachine::new(pk.clone(), sk, None);
        let vm = VerifyMachine::new(pk, None);

        let block = sm.unclean_rekey();
        vm.append_block(block).unwrap();
    }
    */

        /*
        let pk = crypto::to_pubkey(&[
            4, 247, 115, 241, 237, 193, 65, 43,
            166, 186, 127, 179, 128, 23, 195, 41,
            71, 21, 221, 227, 210, 144, 94, 122,
            208, 170, 204, 78, 89, 197, 99, 217
        ]).unwrap();
        let sk = crypto::to_privkey(&[
            43, 57, 142, 134, 84, 184, 194, 225,
            11, 53, 84, 42, 157, 164, 202, 39,
            235, 27, 7, 37, 85, 144, 93, 223,
            159, 197, 79, 25, 177, 12, 107, 45,
            4, 247, 115, 241, 237, 193, 65, 43,
            166, 186, 127, 179, 128, 23, 195, 41,
            71, 21, 221, 227, 210, 144, 94, 122,
            208, 170, 204, 78, 89, 197, 99, 217
        ]).unwrap();
        */

    #[test]
    fn fmt_pointer() {
        let pointer = BlockPointer::from_slice(&[
            0x4f, 0x5e, 0x21, 0xd0, 0xa6, 0x56, 0xe8, 0xfd,
            0xe2, 0xb6, 0xd1, 0x0c, 0x4b, 0x2e, 0x9a, 0x96,
            0x27, 0x3c, 0x6b, 0xb6, 0x20, 0x77, 0xee, 0x66,
            0xbe, 0x1d, 0x18, 0x61, 0x1d, 0xd9, 0xab, 0x3e,
        ]).unwrap();

        assert_eq!(format!("{:x}", pointer), *"4f5e21d0a656e8fde2b6d10c4b2e9a96273c6bb62077ee66be1d18611dd9ab3e");

        let pointer2 = BlockPointer::from_hex(&format!("{:x}", pointer)).unwrap();
        assert_eq!(pointer, pointer2);
    }

    #[test]
    fn sha3() {
        let block = Block::from_network(
            // inner
            InitBlock::from_network(
                // prev
                BlockPointer([
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]),
                // pubkey
                PublicKey::from_slice(&[
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]).unwrap(),
            ).into(),
            // signature
            Signature::from_slice(&[
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            ]).unwrap()
        ).0;

        let expected = BlockPointer([
            0xbf, 0x0a, 0x13, 0xf3, 0x38, 0x42, 0xff, 0xd1,
            0x75, 0xe8, 0xe1, 0x37, 0x34, 0xd7, 0x8c, 0xbe,
            0x85, 0x86, 0xd3, 0x0f, 0xfe, 0x63, 0xcf, 0x78,
            0x33, 0xaf, 0x39, 0x50, 0xa8, 0x4b, 0x6f, 0x57,
        ]);

        assert_eq!(block.sha3(), expected);
    }

    #[test]
    fn init() {
        let (pk, sk) = crypto::gen_keypair();
        let mut sm = SignRing::new(pk, sk);

        let pointer = None;
        let _block = Block::init(pointer.into(), &mut sm).unwrap();
    }

    #[test]
    fn init_bytes() {
        let expected = [
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // previous block
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x00, // op
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // pubkey
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // signature
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        ];

        let block = Block::from_network(
            // inner
            InitBlock::from_network(
                // prev
                BlockPointer([
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]),
                // pubkey
                PublicKey::from_slice(&[
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]).unwrap(),
            ).into(),
            // signature
            Signature::from_slice(&[
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            ]).unwrap()
        ).0;

        let expected = bytes2vec(&expected);
        assert_eq!(expected, block.encode());
    }

    #[test]
    fn rekey() {
        let (pk, sk) = crypto::gen_keypair();
        let mut sm = SignRing::new(pk, sk);

        let pointer = None;
        let dummy = Block::init(pointer.into(), &mut sm).unwrap();

        let _block = Block::rekey(dummy.prev().clone(), &mut sm).unwrap();
    }

    #[test]
    fn rekey_bytes() {
        let expected = [
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // previous block
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, // op
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // pubkey
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // signature
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // signature
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        ];

        let block = Block::from_network(
            // inner
            RekeyBlock::from_network(
                // prev
                BlockPointer([
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]),
                // pubkey
                PublicKey::from_slice(&[
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]).unwrap(),
                // signature
                Signature::from_slice(&[
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]).unwrap()
            ).into(),
            // signature
            Signature::from_slice(&[
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            ]).unwrap()
        ).0;

        let expected = bytes2vec(&expected);
        assert_eq!(expected, block.encode());
    }

    #[test]
    fn alert() {
        let (pk, sk) = crypto::gen_keypair();
        let mut sm = SignRing::new(pk, sk);

        let pointer = None;
        let dummy = Block::init(pointer.into(), &mut sm).unwrap();

        let _block = Block::alert(dummy.prev().clone(), &mut sm, "ohai".as_bytes().to_vec()).unwrap();
    }

    #[test]
    fn alert_bytes() {
        let expected = [
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // previous block
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x02, // op
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // pubkey
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x00, 0x04, // length
            0x6f, 0x68, 0x61, 0x69, // payload
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // signature
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // signature
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        ];

        let block = Block::from_network(
            // inner
            AlertBlock::from_network(
                // prev
                BlockPointer([
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]),
                // pubkey
                PublicKey::from_slice(&[
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]).unwrap(),
                // bytes
                "ohai".as_bytes().to_vec(),
                // signature
                Signature::from_slice(&[
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]).unwrap()
            ).into(),
            // signature
            Signature::from_slice(&[
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            ]).unwrap()
        ).0;

        let expected = bytes2vec(&expected);
        assert_eq!(expected, block.encode());
    }

    #[test]
    fn info() {
        let (pk, sk) = crypto::gen_keypair();
        let mut sm = SignRing::new(pk, sk);

        let pointer = None;
        let dummy = Block::init(pointer.into(), &mut sm).unwrap();

        let _block = Block::info(dummy.prev().clone(), &mut sm, "ohai".as_bytes().to_vec()).unwrap();
    }

    #[test]
    fn info_bytes() {
        let expected = [
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // previous block
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x03, // op
            0x00, 0x04, // length
            0x6f, 0x68, 0x61, 0x69, // payload
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // signature
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // signature
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        ];

        let block = Block::from_network(
            // inner
            InfoBlock::from_network(
                // prev
                BlockPointer([
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]),
                // bytes
                "ohai".as_bytes().to_vec(),
                // signature
                Signature::from_slice(&[
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]).unwrap()
            ).into(),
            // signature
            Signature::from_slice(&[
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
            ]).unwrap()
        ).0;

        let expected = bytes2vec(&expected);
        assert_eq!(expected, block.encode());
    }
}
